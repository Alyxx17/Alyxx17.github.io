---
title: 无约束MPC基本原理
date: 2026-02-05 10:00:00 +0800
categories: [控制,MPC]
tags: [控制]
math: true  # <-- 就是这一行，启用本页的数学公式渲染
---

## 核心原理
MPC控制的基本原理可以概括为：在每个采样时刻用最新得到的测量值刷新优化问题，并求解刷新后的优化问题,将得到的优化解（可能只是次优解）的第一个分量 $u^*(k|k)$作用于系统,如此循环往复至永远。
换句话说，预测控制算法包括三个步骤：  

（1）预测系统未来动态:  

（2）(数值) 求解优化问题;  

（3） 将优化解的第一个元素 (或者说一部分)作用于系统；  

实际上通俗来说，MPC预测控制有点类似于下棋：根据当前时刻的状态预测推演接下来的几步，但是只下一步，如此往复。  
## 增量离散状态空间模型

考虑如下连续时间域的状态空间方程:  

$$
\begin{aligned}
\dot{x}(t) &= A_c x(t) + B_{cu} u(t) + B_{cd} d(t); \\
y_c(t) &= C_c x(t).
\end{aligned}
$$  

其中$x(t)$是状态变量，$u(t)$是控制输入变量，$d(t)$是可以测量的外部干扰变量， $y_c$ 是被控输出变量;  

为了便于计算机控制，将上述连续时间域的状态空间方程转化为离散时间域的状态空间方程。其系数有如下关系：  

\begin{aligned}
A & =\mathrm{e}^{A_{c} T_{s}} 
\end{aligned}  

\begin{aligned}
B_{u} & =\int_{0}^{T_{s}} \mathrm{e}^{A_{c} \tau} \mathrm{~d} \tau \cdot B_{c u}
\end{aligned}  

\begin{aligned}
B_{d} & =\int_{0}^{T_{s}} \mathrm{e}^{A_{c} \tau} \mathrm{~d} \tau \cdot B_{c d}
\end{aligned}  
其中$T_s$为采样时间。  
因此，离散域的状态空间方程可以表示为:  

$$
\begin{aligned}
x(k+1) &= Ax(k) + B_u u(k) + B_d d(k); 
\end{aligned}  
$$

$$
\begin{align}
y_c(k) &= C_c x(k).\tag{1}
\end{align}
$$  

为了引入积分作用以减小或消除静态误差，采用增量离散状态空间模型。  
定义:
\begin{aligned}
Δx(k) &= x(k)-x(k-1);
\end{aligned}  

\begin{aligned}
Δu(k) &= u(k)-u(k-1);
\end{aligned}  

\begin{aligned}
Δd(k) &= d(k)-d(k-1);
\end{aligned}  

由此可得增量离散状态空间模型为：

$$
\begin{aligned}
\Delta x(k+1) &= A \Delta x(k) + B_u \Delta u(k) + B_d \Delta d(k); \\
y_c(k) &= C_c \Delta x(k) + y_c(k-1). 
\end{aligned}
$$

本文以后的推导都基于这个增量离散状态空间模型（下称“状态空间模型”）。  
## 预测方程  
这一节将讨论MPC的第一个步骤：基于上述的状态空间模型预测系统未来的动态。  
假设所有状态变量均可测量，以最新的测量值为初始条件，设置预测时域为$p$，控制时域为$m$，且$m$≤$p$。为了便于推导，作如下假设：  
(1)控制时域之外，控制量不变，即$Δu(k+i)$=$0$,$i$=$m$,$m+1$,......,$p-1$;  

(2)可测干扰在k时刻之后保持不变，即$Δd(k+i)$=$0$,$i$=$1$,$2$,......,$p$;  


基于这两个假设，先预测状态变量，在当前时刻$k$,测量值为$x(k)$,可以计算$Δx(k)=x(k)-x(k-1)$，这个$Δx(k)$将作为预测系统未来状态的起点。式中$(k+i\vert k)$代表从$k$开始预测到$k+i$时刻。即：  

$$
\begin{aligned}
\Delta x(k+1|k) &= A\Delta x(k) + B_u\Delta u(k) + B_d\Delta d(k), \\
\Delta x(k+2|k) &= A\Delta x(k+1|k) + B_u\Delta u(k+1) + B_d\Delta d(k+1) \\
&= A^2\Delta x(k) + AB_u\Delta u(k) + B_u\Delta u(k+1) + AB_d\Delta d(k), \\
\Delta x(k+3|k) &= A\Delta x(k+2|k) + B_u\Delta u(k+2) + B_d\Delta d(k+2) \\
&= A^3\Delta x(k) + A^2B_u\Delta u(k) + AB_u\Delta u(k+1) + B_u\Delta u(k+2) + A^2B_d\Delta d(k).
\end{aligned}
$$ 

$$
\vdots
$$



$$
\begin{aligned}
\Delta x(k + m|k) &= A\Delta x(k + m - 1|k) + B_u \Delta u(k + m - 1) + B_d \Delta d(k + m - 1) \\
&= A^m \Delta x(k) + A^{m-1} B_u \Delta u(k) + A^{m-2} B_u \Delta u(k + 1) \\
&\quad + \cdots + B_u \Delta u(k + m - 1) + A^{m-1} B_d \Delta d(k), \\
&\vdots \\
\Delta x(k + p|k) &= A\Delta x(k + p - 1|k) + B_u \Delta u(k + p - 1) + B_d \Delta d(k + p - 1) \\
&= A^p \Delta x(k) + A^{p-1} B_u \Delta u(k) + A^{p-2} B_u \Delta u(k + 1) \\
&\quad + \cdots + A^{p-m} B_u \Delta u(k + m - 1) + A^{p-1} B_d \Delta d(k).
\end{aligned}
$$  

进一步，利用上面预测的状态，可以预测被控输出： 

$$
\begin{aligned}
y_c(k+1|k) &= C_c \Delta x(k+1|k) + y_c(k) \\
&= C_c A \Delta x(k) + C_c B_u \Delta u(k) + C_c B_d \Delta d(k) + y_c(k), \\
y_c(k+2|k) &= C_c \Delta x(k+2|k) + y_c(k+1|k) \\
&= (C_c A^2 + C_c A) \Delta x(k) + (C_c AB_u + C_c B_u) \Delta u(k) \\
&\quad + C_c B_u \Delta u(k+1) + (C_c AB_d + C_c B_d) \Delta d(k) + y_c(k), \\
&\vdots \\
y_c(k+m|k) &= C_c \Delta x(k+m|k) + y_c(k+m-1|k) \\
&= \sum_{i=1}^m C_c A^i \Delta x(k) + \sum_{i=1}^m C_c A^{i-1} B_u \Delta u(k) \\
&\quad + \sum_{i=1}^{m-1} C_c A^{i-1} B_u \Delta u(k+1) + \cdots + C_c B_u \Delta u(k+m-1) \\
&\quad + \sum_{i=1}^m C_c A^{i-1} B_d \Delta d(k) + y_c(k), \\
&\vdots \\
y_c(k+p|k) &= C_c \Delta x(k+p|k) + y_c(k+p-1|k) \\
&= \sum_{i=1}^p C_c A^i \Delta x(k) + \sum_{i=1}^p C_c A^{i-1} B_u \Delta u(k) \\
&\quad + \sum_{i=1}^{p-1} C_c A^{i-1} B_u \Delta u(k+1) + \dots \\
&\quad + \sum_{i=1}^{p-m+1} C_c A^{i-1} B_u \Delta u(k+m-1) \\
&\quad + \sum_{i=1}^p C_c A^{i-1} B_d \Delta d(k) + y_c(k).
\end{aligned}
$$  

定义$p$步预测输出向量和$m$步输入向量如下:  

$$ 
\begin{aligned}
Y_p(k+1|k) \stackrel{\text{def}}{=}
  \begin{pmatrix}
  y_c(k+1|k) \\
  y_c(k+2|k) \\
  \vdots \ \\
  y_c(k+p|k) \\
  \end{pmatrix}_{p \times 1}
\end{aligned}  
$$  

$$
\begin{aligned}
\Delta U(k) \stackrel{\text{def}}{=}
\begin{bmatrix}
\Delta u(k) \\
\Delta u(k+1) \\
\vdots \\
\Delta u(k+m-1)
\end{bmatrix}_{m \times 1}.
\end{aligned}
$$  

注意：矩阵下标表示的是矩阵中向量 (或标量)的个数,不一定是矩阵的维数. 例如,上式中, $p×1$仅表示矩阵$Y_p(k+1\vert k)$中$y_c$的个数, 当$y_c$是向量时,$p×1$并不等于矩阵的维数.  

同时需要注意的是$k$时刻的$u(k)$不是已知量，而是需要施加到系统的第一个控制量。因此$Δu(k)$不是初始条件。  

那么, 根据上面的预测推导，可以将各步的矩阵系数增广组合，对系统未来$p$步预测的输出可以由下面的预测方程计算:  

$$
\begin{align}
Y_p(k + 1|k) = S_x \Delta x(k) + I y_c(k) + S_d \Delta d(k) + S_u \Delta U(k),\tag{2}
\end{align}
$$

其中：  

$$
\begin{align}
S_x = 
\begin{bmatrix}
C_c A \\
\sum_{i=1}^{2} C_c A^i \\
\vdots \\
\sum_{i=1}^{p} C_c A^i
\end{bmatrix}_{p \times 1}, \tag{3} \quad I =
\begin{bmatrix}
I_{n_c \times n_c} \\
I_{n_c \times n_c} \\
\vdots \\
I_{n_c \times n_c}
\end{bmatrix}_{p \times 1},
\end{align}
$$  

$I_{n_c \times n_c}$中的下标代表输出维数，即$C_c$的行数。

$$
\begin{align}
S_d =
\begin{bmatrix}
C_c B_d \\
\sum_{i=1}^2 C_c A^{i-1} B_d \\
\vdots \\
\sum_{i=1}^p C_c A^{i-1} B_d
\end{bmatrix}_{p \times 1},\tag{4}
\end{align}
$$  

$$
\begin{align}
S_u =
\begin{bmatrix}
C_c B_u & 0 & 0 & \cdots & 0 \\
\sum_{i=1}^2 C_c A^{i-1} B_u & C_c B_u & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\sum_{i=1}^m C_c A^{i-1} B_u & \sum_{i=1}^{m-1} C_c A^{i-1} B_u & \cdots &  \cdots &C_c B_u \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\sum_{i=1}^p C_c A^{i-1} B_u & \sum_{i=1}^{p-1} C_c A^{i-1} B_u & \cdots & \cdots &\sum_{i=1}^{p-m+1} C_c A^{i-1} B_u
\end{bmatrix}_{p \times m}\tag{5}
\end{align}
$$

$S_u$中前$m$行构成的下三角矩阵，很好的说明了系统在时间上的因果关系。比如当$S_u$与$\Delta U(k)$相乘时，第一行只有$Δu(k)$的系数不为$0$，$Δu(k+1)$，$Δu(k+2)$......的系数都为0，而这行也对应了$y_c(k+1\vert k)$，而第二行只有$Δu(k)$，$Δu(k)$的系数不为$0$,这行对应了$y_c(k+2\vert k)$，说明$k+1$时刻的输入对$k$时刻的输出没有影响，$k+2$时刻的输入对$k$，$k+1$时刻的输出没有影响，以此类推。  

为了更好的理解$S_u$矩阵，$S_u$可以表示为如下形式(假设$p=20$,$m=5$):  

$$
\begin{aligned}
S_u = 
\begin{bmatrix}
h_1 & 0 & 0 & 0 & 0 \\
h_2 & h_1 & 0 & 0 & 0 \\
h_3 & h_2 & h_1 & 0 & 0 \\
h_4 & h_3 & h_2 & h_1 & 0 \\
h_5 & h_4 & h_3 & h_2 & h_1 \\
h_6 & h_5 & h_4 & h_3 & h_2 \\
h_7 & h_6 & h_5 & h_4 & h_3 \\
h_8 & h_7 & h_6 & h_5 & h_4 \\
h_9 & h_8 & h_7 & h_6 & h_5 \\
h_{10} & h_9 & h_8 & h_7 & h_6 \\
h_{11} & h_{10} & h_9 & h_8 & h_7 \\
h_{12} & h_{11} & h_{10} & h_9 & h_8 \\
h_{13} & h_{12} & h_{11} & h_{10} & h_9 \\
h_{14} & h_{13} & h_{12} & h_{11} & h_{10} \\
h_{15} & h_{14} & h_{13} & h_{12} & h_{11} \\
h_{16} & h_{15} & h_{14} & h_{13} & h_{12} \\
h_{17} & h_{16} & h_{15} & h_{14} & h_{13} \\
h_{18} & h_{17} & h_{16} & h_{15} & h_{14} \\
h_{19} & h_{18} & h_{17} & h_{16} & h_{15} \\
h_{20} & h_{19} & h_{18} & h_{17} & h_{16}
\end{bmatrix}_{20\times5}
\end{aligned}
$$

其中：
$h_k = \displaystyle\sum_{i=1}^k C_c A^{i-1} B_u ，k = 1,2,\dots,p $  

## 求解优化问题  
目标函数的选取反映对系统性能的要求，我们希望被控输出接近参考输入，同时希望控制动作不要变化太大。考虑如下目标函数：  

$$
\begin{aligned}
J = \sum_{i=1}^p \left|| \Gamma_{y,i} (y_c(k + i|k) - r(k + i)) \right||^2 + \sum_{i=1}^m \left|| \Gamma_{u,i} \Delta u(k + i - 1) \right||^2,
\end{aligned}  
$$  

其中：  
 
$$
\begin{aligned}
\Gamma_{y,i} \stackrel{\text{def}}{=} \operatorname{diag}(\Gamma_{y_1,i}, \Gamma_{y_2,i}, \cdots, \Gamma_{y_{n_c},i}).
\end{aligned}
$$  

其中$\Gamma_{y_1,i}, \Gamma_{y_2,i}, \cdots, \Gamma_{y_{n_c},i}$为标量，代表在$i$时刻对各个输出(一共$n_c$个，即状态空间模型中矩阵$C_c$的行数）误差的加权因子。 误差加权因子越大,表明我们期望对应的控制输出越接近给定的参考输入。   

$$
\begin{aligned}
\Gamma_{u,i} \stackrel{\text{def}}{=} \operatorname{diag}(\Gamma_{u_1,i}, \Gamma_{u_2,i}, \cdots, \Gamma_{u_{n_u},i})
\end{aligned}
$$  

其中$\Gamma_{u_1,i}, \Gamma_{u_2,i}, \cdots, \Gamma_{u_{n_u},i}$为标量，代表在$i$时刻对各个控制增量（一共$n_u$个，即状态空间模型中矩阵$B_u$的列数）的加权因子。  控制加权因子越大，表明我们期望对应的控制动作变化越小。 

$r(k+i)$代表给定参考输入向量。 


为了更好地理解这两个加权因子。假设一2输入2输出系统。  

那么$i=1$时刻的误差为$(y_c(k + 1\vert k) - r(k + 1)$，这是一个$2×1$的矩阵（注意，$r(k + 1)$是参考输入，不是控制量，在维数上应和$y_c(k + 1\vert k)$相等）。  

此时对于$i=1$的2个输出分别采取不同的加权因子$\Gamma_{y_1,1}, \Gamma_{y_2,1}$，假设为$1,0.5$。即：  

$$
\begin{aligned}
\Gamma_{y,1} = \text{diag}(\Gamma_{y_1,1}, \Gamma_{y_2,1}) =
\begin{bmatrix}
1 & 0 \\
0 & 0.5
\end{bmatrix}
\end{aligned}
$$

下一个时刻$i=2$时的2个输出分别采取不同的加权因子$\Gamma_{y_1,2}, \Gamma_{y_2,2}$，假设为$0.8,1$。即：  

$$
\begin{aligned}
\Gamma_{y,2} = \text{diag}(\Gamma_{y_1, 2}, \Gamma_{y_2, 2}) =
\begin{bmatrix}
0.8 & 0 \\
0 & 1
\end{bmatrix}
\end{aligned}
$$  

同样的，$i=1$时刻的$Δu(k)$是一个$2×1$的矩阵，此时，对这个2个控制量分别采用不同的加权因子$\Gamma_{u_1,1}, \Gamma_{u_2,1}$，假设分别为$0.2,0.4$。即：  

$$
\begin{aligned}
\Gamma_{u,1} = \text{diag}(\Gamma_{u_1,1}, \Gamma_{u_2,1}) =
\begin{bmatrix}
0.2 & 0 \\
0 & 0.4
\end{bmatrix}
\end{aligned}
$$

下一时刻$i=2$时，对这个2个控制量分别采用不同的加权因子$\Gamma_{u_1,2}, \Gamma_{u_2,2}$，假设分别为$0.3,0.1$。即：  

$$
\begin{aligned}
\Gamma_{u,2} = \text{diag}(\Gamma_{u_1, 2}, \Gamma_{u_2, 2}) =
\begin{bmatrix}
0.3 & 0 \\
0 & 0.1
\end{bmatrix}
\end{aligned}
$$  

上述的加权因子在整个预测时域中会变化（是指时刻$i$变化时，对应的对角阵也变化），称为时变加权因子。当然，有时系统易于控制时，可以选择恒值的加权因子。  


若把目标函数写为矩阵向量的形式，即：  

$$
\begin{aligned}
J(x(k), \Delta U(k), m, p) = || \Gamma_y (Y_p(k+1|k) - R(k+1)) ||^2 + || \Gamma_u \Delta U(k) ||^2,
\end{aligned}
$$  

其中：  
$$
\begin{aligned}
\Gamma_y &= \text{diag}(\Gamma_{y,1}, \Gamma_{y,2}, \cdots, \Gamma_{y,p}), \\
\Gamma_u &= \text{diag}(\Gamma_{u,1}, \Gamma_{u,2}, \cdots, \Gamma_{u,m}),
\end{aligned}
$$

注意，这个$\Gamma_{y,1}, \Gamma_{y,2}, \cdots, \Gamma_{y,p}$与$\Gamma_{u,1}, \Gamma_{u,2}, \cdots, \Gamma_{u,m}$不再是标量，每一个都是一个对角阵（就是上述例子中每一个时刻对每个分量组合起来的对角阵）。

$$
\begin{aligned}
R(k+1) =
\begin{bmatrix}
r(k+1) \\
r(k+2) \\
\vdots \\
r(k+p)
\end{bmatrix}_{p \times 1}.
\end{aligned}
$$
为参考输入序列。  

为了方便这个优化问题，定义辅助变量:  

$$
\begin{aligned}
\rho \stackrel{\text{def}}{=}
\left[
\begin{array}{c}
\Gamma_y \left( Y_p(k+1|k) - R(k+1) \right) \\
\Gamma_u \Delta U(k)
\end{array}
\right],
\end{aligned}
$$

那么目标函数$J(x(k), \Delta U(k), m, p)=\rho ^T\rho$;  

将预测方程带入上式，有：

$$
\begin{aligned}
\rho &=
\begin{bmatrix}
\Gamma_y (S_x \Delta x(k) + I y_c(k) + S_d \Delta d(k) + S_u \Delta U(k) - R(k+1)) \\
\Gamma_u \Delta U(k)
\end{bmatrix} \\
&=
\begin{bmatrix}
\Gamma_y S_u \\
\Gamma_u
\end{bmatrix} \Delta U(k)-
\begin{bmatrix}
\Gamma_y (R(k+1) - S_x \Delta x(k) - I y_c(k) - S_d \Delta d(k)) \
\end{bmatrix} \\
&=
\begin{bmatrix}
\Gamma_y S_u \\
\Gamma_u
\end{bmatrix} \Delta U(k) -
\begin{bmatrix}
\Gamma_y E_p (k+1|k) \\
0
\end{bmatrix} \\
&= Az - b.
\end{aligned}
$$  

上式中，  

$$
\begin{aligned}
z &= \Delta U(k), \quad A =
\begin{bmatrix}
\Gamma_y S_u \\
\Gamma_u
\end{bmatrix}, \quad b =
\begin{bmatrix}
\Gamma_y E_p(k+1|k) \\
\mathbf{0}
\end{bmatrix} \\
\end{aligned}
$$  

$$
\begin{align}
E_p(k+1|k) &= R(k+1) - S_x \Delta x(k) - I y_c(k) - S_d \Delta d(k)\tag{6}
\end{align}
$$

因此，优化问题可化为：  
$$
\begin{aligned}
\min_z \rho^T \rho, \rho = Az - b.
\end{aligned}
$$

由$\rho^T \rho = (Az - b)^T (Az - b)$的极值条件：  

$\frac{d\rho^T \rho}{dz} = 2 \left( \frac{d\rho}{dz} \right)^T \rho = 2A^T (Az - b) = 0 \$  

得极值解为： $z^* = (A^T A)^{-1} A^T b.$
 
注意，此处的极值解不是 $A^{-1}b$,因为$A$不是方阵，此解为最小二乘解。  

又由：  

$$
\begin{aligned}
\frac{d^2(\rho^T \rho)}{dz^2} = 2A^T A > 0
\end{aligned}
$$  

可知此解为最小值解，因此k时刻的最优控制序列为：  

$$
\begin{align}
\Delta U^*(k) = \left( S_u^T \Gamma_y^T \Gamma_y S_u + \Gamma_u^T \Gamma_u \right)^{-1} S_u^T \Gamma_y^T \Gamma_y E_p (k+1|k)\tag{7}
\end{align}
$$

**注意：虽然在优化问题的目标函数中考虑了对控制不能变化太大的约束，但这只是软约束。因此仍为无约束MPC控制。约束MPC控制指在优化问题中显示包含形如：**  

$$
\begin{aligned}
u_{\min} &\leq u(k + i) \leq u_{\max}, \quad i = 0, 1, \cdots, m - 1 \\
\Delta u_{\min} &\leq \Delta u(k + i) \leq \Delta u_{\max}, \quad i = 0, 1, \cdots, m - 1
\end{aligned}
$$

**的时域硬约束。**


## 优化解的第一个元素作用于系统
这一节将讨论MPC的最后一个步骤，即将优化解的第一个元素作用于系统。  即：

$$
\begin{aligned}
\Delta u(k) &=
\begin{bmatrix}
I_{n_u \times n_u} & 0 & \cdots & 0
\end{bmatrix}_{1 \times m} \Delta U^*(k) \\
&=
\begin{bmatrix}
I_{n_u \times n_u} & 0 & \cdots & 0
\end{bmatrix}_{1 \times m}
\left( S_u^T \Gamma_y^T \Gamma_y S_u + \Gamma_u^T \Gamma_u \right)^{-1} S_u^T \Gamma_y^T \Gamma_y E_p (k + 1|k).
\end{aligned}
$$

定义预测控制增益：  

$$
\begin{align}
K_{\text{mpc}} = \begin{bmatrix} I_{n_u \times n_u} & \mathbf{0} & \cdots & \mathbf{0} \end{bmatrix}_{1 \times m} \left( S_u^T \Gamma_y^T \Gamma_y S_u + \Gamma_u^T \Gamma_u \right)^{-1} S_u^T \Gamma_y^T \Gamma_y.\tag{8}
\end{align}
$$  

那么控制增量可以由下式计算：

$$
\begin{align}
\Delta u(k) = K_{\text{mpc}} E_p (k + 1|k)\tag{9}
\end{align}
$$

其中 $E_p(k+1\vert k)$可由$(6)$在线计算。显然，如果加权阵 $\Gamma_y$ 和 $\Gamma_u$ 是与时间无关的常数，则 $K_{\text{mpc}}$ 可由$(8)$离线计算。在 $k+1$ 时刻，得到新的测量值 $x(k+1)$，将由预测方程$(2)$重新计算系统未来的输出，并由$(7)$计算最优控制序列 $\Delta U^*(k+1)$。最后，由预测控制基本原理中的“滚动时域、重复进行”的机制，给出无约束预测控制的算法如下。  

## 算法
(1) 初始化：设定预测时域 $p$ 和控制时域 $m$，初始值 $u(-1) = 0, x(-1) = 0$；由$(3),(4),(5)$计算 $S_x, I, S_d$和$S_u$，由$(8)$计算 $K_{\text{mpc}}$。  

(2) $k \geq 0$ 时刻，得到测量值 $x(k)$ 和 $d(k)$。由$(1)$计算 $y_c(k)$；计算 $\Delta x(k) = x(k) - x(k-1)$。  

(3) 由$(6)$计算误差 $E_p(k+1\vert k)$。  

(4) 由$(9)$计算控制量变化量 $\Delta u(k)$。  

(5) 将 $u(k) = u(k-1) + \Delta u(k)$ 作用于系统。  

(6) 在 $k+1$ 时刻，测量 $x(k+1)$ 和 $d(k+1)$ 的值，并且令 $k = k+1$，返回第 (2) 步。  

注:如果采用时变加权因子，则 $K_{\text{mpc}}$ 的计算或者部分计算也将在循环内进行。  

## 稳定性分析  

考虑一些不确定因素，被控系统的数学描述为：  

$$
\begin{align}
\Delta x(k+1) = A \Delta x(k) + B_u \Delta u(k) + B_d \Delta d(k) + B_w \Delta w(k).\tag{10}
\end{align}
$$  

其中，$\Delta w(k)$为不可测量的外部干扰。

将式$(1)$和式$(6)$带入式$(9)$，同时考虑到$x(k)=x(k-1)+Δx(k)$,有： 

$$
\begin{aligned}
\Delta u(k) &= K_{\text{mpc}} \left( R(k+1) - S_x \Delta x(k) - I C_c x(k) - S_d \Delta d(k) \right) 
\end{aligned}
$$

$$
\begin{align}
&= K_{\text{mpc}} R(k+1) - K_{\text{mpc}} \left( S_x + I C_c \right) \Delta x(k) - K_{\text{mpc}} I C_c x(k-1) - K_{\text{mpc}} S_d \Delta d(k).\tag{11}
\end{align}
$$

将式(11)带入式(10)，得到闭环系统为：

$$
\begin{aligned}
\Delta x(k+1) &= (A - B_u K_{\text{mpc}}(\mathcal{S}x + \mathcal{I}C_c)) \Delta x(k) + B_u K{\text{mpc}} R(k+1) + B_w \Delta w(k) \\
&\quad + (B_d - B_u K_{\text{mpc}} S_d) \Delta d(k) - B_u K_{\text{mpc}} I C_c x(k-1).
\end{aligned}
$$

显然，当矩阵$A - B_u K_{\text{mpc}}(\mathcal{S}x + \mathcal{I}C_c)$的特征值都在单位圆内时，系统稳定。

## 性能分析   

稳定性是讨论系统性能的前提，下面关于抗干扰性能以及无静差跟踪的讨论均假设系统$(10)$是名义渐近稳定的。  

### 抗干扰性能  

令$R(k+1)=0$，系统$(10)$变为：    

$$
\begin{aligned}
\Delta x(k+1) &= (A - B_u K_{\text{mpc}}(\mathcal{S}x + \mathcal{I}C_c)) \Delta x(k) + B_w \Delta w(k) \\
&\quad + (B_d - B_u K_{\text{mpc}} S_d) \Delta d(k) - B_u K_{\text{mpc}} I C_c x(k-1).
\end{aligned}
$$ 

如果干扰趋于不变，即当$k→∞$时，$Δd(k)→0$，$Δw(k)→0$，那么上式变为：  

$$
\begin{aligned}
\Delta x(k+1) &= (A - B_u K_{\text{mpc}}(\mathcal{S}x + \mathcal{I}C_c)) \Delta x(k)- B_u K_{\text{mpc}} I C_c x(k-1).
\end{aligned}
$$

当干扰趋于不变时，没有外部驱动力使得状态变量继续变化，在闭环稳定的前提下，系统的状态变量会保持在某个值，因此$Δ(k)→0$，进而$Δy_c(k)→0$。所以可测与不可测的外部干扰趋于不变时，闭环系统的状态和输出都是有界的。  


### 无静差跟踪  
这节讨论外部干扰趋于不变的情况下（即$Δd(k)→0，Δw(k)→0$），系统对于非零参考信号的跟踪能力。

为了简化推导，假设$n_u=n_c$，即控制输出维数等于控制输入维数，这个假设使得矩阵$C_u*B_u$是一个方阵。同时$Γ_u=0,Γ_y=I$，以及$m=p$。

式$(8)$变为：

$$
\begin{aligned}
K_{\text{mpc}} &=
\begin{bmatrix}
I_{n_u \times n_u} & \mathbf{0} & \cdots & \mathbf{0}
\end{bmatrix}_{1 \times m}
\left( S_u^T S_u \right)^{-1} S_u^T \\
&=
\begin{bmatrix}
I_{n_u \times n_u} & \mathbf{0} & \cdots & \mathbf{0}
\end{bmatrix}_{1 \times m}
S_u^{-1}.
\end{aligned}
$$

$$
\begin{aligned}
K_{\text{mpc}} = \begin{bmatrix} I_{n_u \times n_u} & 0 & \cdots & 0 \end{bmatrix}_{1 \times m}
\begin{bmatrix}
(C_c B_u)^{-1} & 0 & \cdots & 0 \\
& (C_c B_u)^{-1} & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
& * & \cdots & (C_c B_u)^{-1}
\end{bmatrix}_{m \times m}.
\end{aligned}
$$

上式省略的下三角以及*代表的矩阵在下文推导没有作用，故省略，此时有： 

$$
\begin{aligned}
K_{\text{mpc}} = \left( C_c B_u \right)^{-1}
\begin{bmatrix}
I_{n_u \times n_u} & \mathbf{0} & \cdots & \mathbf{0}
\end{bmatrix}_{1 \times m}.
\end{aligned}
$$

将其代入$(9)$，同时考虑$(6)$以及$(3)$，有：

$$
\begin{aligned}
\Delta u(k) &= (C_c B_u)^{-1} \left[ I_{n_u \times n_u} \mathbf{0} \cdots \mathbf{0} \right]_{1 \times m} \left( R(k+1) - S_x \Delta x(k) - I y_c(k) \right) \\
&= (C_c B_u)^{-1} \left( r(k+1) - C_c A \Delta x(k) - y_c(k) \right). 
\end{aligned}
$$

将其代入$(10)$，有：  

$$
\begin{aligned}
\Delta x(k+1) = A \Delta x(k) + B_u (C_c B_u)^{-1} (r(k+1) - C_c A \Delta x(k) - y_c(k)).
\end{aligned}
$$ 

结合$y_c(k+1) = C_c \Delta x(k+1) + y_c(k)$,有：  

$$
\begin{aligned}
y_c(k+1) &= C_c \Delta x(k+1) + y_c(k) \\
&= C_c B_u (C_c B_u)^{-1} (r(k+1) - C_c A \Delta x(k) - y_c(k)) + C_c A \Delta x(k) + y_c(k) \\
&= r(k+1).
\end{aligned}
$$

进一步，  

$$
\begin{aligned}
y_c(k+2) &= C_c \Delta x(k+2) + y_c(k+1) \\
&= C_c B_u (C_c B_u)^{-1} (r(k+2) - C_c A \Delta x(k+1) - y_c(k+1)) + C_c A \Delta x(k+1) + y_c(k+1) \\
&= r(k+2)
\end{aligned}
$$  

不难得出，$y_c(k+i)=r(k+i)，i=1,2,3,......p$;因此在外部干扰趋于不变的情况下，是可以实现无静差跟踪的。 

## 常见问题  

### 采样周期，预测时域与控制时域如何选择？又如何影响系统性能？

**采样周期**：  

根据经验法则，建议将采样周期$T_s$设定为期望最小闭环响应时间的10%至25%（例如，你希望一个电机转速在0.1秒内稳定到新设定值，那么$T_s$初选就在10ms到25ms之间。）。  

至少进行一次仿真测试，观察当$T_s$减半时系统对未测量干扰的抑制能力是否显著提升。若存在明显改善，则应考虑调整$T_s$的取值。

在过程控制领域，采样周期通常远大于1秒（$T_s$>>$1s$），尤其当模型预测控制（MPC）用于监管底层单回路控制器时。而在汽车或航空航天等应用场景中，则往往要求采样周期小于1秒（$Ts$<$1s$）。若实时求解二次规划问题所需时间超过设定的采样周期，可考虑采用显式模型预测控制方案。

对于具有时滞特性的被控对象，建模所需的状态变量数量与采样周期$T_s$成反比关系。

针对开环不稳定的被控对象，若预测时域总时长（$p*T_s$）设置过大，导致在该时间段内被控对象的阶跃响应趋于无穷，则模型预测控制计算所需的关键参数将无法定义。

**预测时域**:  

推荐做法是在控制器设计的早期阶段确定预测时域$p$，并在调整其他控制器参数（如加权矩阵）时保持$p$恒定。换言之，不应将调整$p$作为控制器整定的手段。$p$的取值应确保控制器内部稳定，并能足够提前地预测到约束违规，从而采取纠正措施。

设定参考：若期望的闭环响应时间为$T$，采样周期为$T_s$，可尝试将$p$设置为满足$T≈p*T_s$的值。

时滞限制：被控对象的时滞会对可能的闭环响应时间设定一个下限。应据此选择$p$。

性能饱和：推荐的做法是逐步增大$p$，直到其继续增加对性能的提升影响甚微为止。若被控对象开环不稳定，则$p$的最大值受限于开环阶跃响应变为无穷大所需的控制周期数。除非$T_s$过小，否则$p>50$通常没有必要。

潜在问题与对策
当被控对象特性不佳且$p$取值过小时，可能导致控制器内部不稳定。  

如果$p$已经较大，可考虑以下替代方案：

增大控制周期$T_s$。

增加目标函数中被控变量增量的权重。

调整控制时域或采用被控变量分块技术（参见“被控变量分块”章节https://ww2.mathworks.cn/help/mpc/ug/manipulated-variable-blocking.html）。

结合使用较小的$p$与终端权重（不是指目标函数/代价函数，也不是指加权矩阵，本文没有提及这个概念，感兴趣可以查阅相关资料），以近似线性二次调节器的性能（参见“终端权重与约束”章节https://ww2.mathworks.cn/help/mpc/ug/terminal-weights-and-constraints.html）。  

**控制时域**：  

将控制时域$m$设置为远小于预测时域$p$（即$m$<<$p$）主要基于以下几点考虑：

降低计算复杂度：较小的$m$意味着在每个控制周期需要求解的二次规划问题中，优化变量更少，这有助于显著提升计算速度。

避免奇异问题（尤其针对有时滞的对象）：若被控对象包含时滞，则必须满足$m$<$p$。否则，部分被控变量的调整动作在预测时域结束前可能完全无法影响任何输出，这将导致二次规划问题的海森矩阵(Hessian)奇异，使求解失败。

增强稳定性倾向：较小的$m$有助于（但不保证）控制器的内部稳定。需要注意的是，相较于简单的控制时域概念，被控变量分块技术能提供更灵活的调节方式。详细信息请参阅“被控变量分块”章节(https://ww2.mathworks.cn/help/mpc/ug/manipulated-variable-blocking.html)。


### MPC和LQR（线性二次调节器）的区别与联系，各自的优势与缺点  

从根本思想上，MPC和LQR都遵循“模型驱动”和“优化目标”的核心框架。它们都基于被控对象的数学模型，并通过最小化一个定义明确的二次型性能指标（通常包含状态偏差和控制量）来求解最优控制动作。

在某些特定条件下，无约束的、无限时域的线性MPC等价于LQR。这是两者最重要的理论联系。也就是说，LQR可以被看作是MPC的一个特例。  

如果我们将MPC的预测时域$p$设置为无穷大，并且没有任何约束，那么它求解的优化问题在数学上完全等同于LQR问题。MPC的滚动实施策略在无约束、无限时域下退化为一个固定的状态反馈，无限时域MPC在数值上是无法直接求解的，因为它需要求解一个无限维的优化问题，因此需用LQR解析解。  

当预测时域有限，但具有特定设计的终端代价的无约束MPC，一般视作与LQR渐近等价或性能等价，而不是严格的数学恒等。

| 性质   | LQR (线性二次调节器) | MPC (模型预测控制)|
| :-----: | :--: | :-------: |
|核心机制 |离线计算，在线查表。|在线滚动优化。 |
| 时域 |无限时域优化。| 有限时域优化。 |
| 约束处理 |天然无法处理任何约束。 |可以将状态约束、控制输入约束、输出约束等显式地作为优化问题的边界条件，在求解最优解时自动满足。|
|模型类型 |严格的线性模型。| 高度灵活。|
| 前瞻性 |无。| 有。 |
| 计算负担 |极低。| 较高。 |
|设计复杂度 |相对简单。 |更复杂。 |
| 优点 |计算高效，保证全局最优和稳定性，设计相对简单。| 约束处理能力，多变量控制，前瞻性与优化性能，模型灵活性。 |
| 缺点 |无法处理约束，仅限于线性系统，无前瞻能力 。| 计算负担重，设计复杂度高，对模型精度敏感，稳定性非天然保证。|
 
### 两个加权系数矩阵的选取原则？  
在进行加权系数矩阵的选取前，应先对每个被控对象的输入和输出变量进行归一化（当某些变量的量级远大于或小于其他变量时，这一点尤其重要。）。缩放因子应等于（或近似于）该变量的跨度。跨度是指其在工程单位（即被控对象模型中指定的度量单位）下的最大值与最小值之差。在内部，MPC 将每个被控对象的输入和输出信号除以其缩放因子，以生成无量纲信号。在同样的条件下，某一个变量的范围取得越大，相当于在目标函数中对这项惩罚越小。  

若不进行归一化，加权系数一个会很大，一个会很小。例如若是控制三体船减摇中，误差的单位是度，控制增量的单位是力矩，在数值上差很多，在设计系数会出现一个数值很大，一个数值很小（例如一个30000，一个0.001），这是因为需要考虑实际物理单位，不够直观。

**设定缩放因子的潜在益处:**

优化默认权重效果：当所有信号量级约为$1$时，默认的MPC调整权重效果最佳。恰当的缩放因子能使默认权重成为控制器调整和优化的良好起点。

简化权重选择：在选择目标函数权重时，可以专注于各项之间的相对优先级，而无需同时考虑优先级和信号量级。

改善数值条件：当值经过缩放后，舍入误差对计算的影响会减小。

一旦完成控制器调整，更改缩放因子可能会影响性能，控制器可能需要重新调整。最佳实践是在控制器设计初期确定缩放因子，并在之后保持其恒定。  

**确定缩放因子:**
要确定缩放因子，请估算每个被控对象输入和输出变量在工程单位下的跨度。

若信号已知边界：使用上限和下限之差。

若不知信号边界：考虑运行开环被控对象模型仿真。在其可能的范围内改变输入，并记录输出信号的跨度。

若完全未知：使用默认缩放因子 (=1)。  

**误差加权系数的选取建议：**  

大致指南如下：

0.05 — 低优先级：可接受较大的跟踪误差

0.2 — 低于平均水平的优先级

1 — 平均优先级（默认值）。如果$n_{yc}$= 1(输出维度为1），请使用此值。

5 — 高于平均水平的优先级

20 — 高优先级：期望较小的跟踪误差  

**控制加权系数的选取建议：**    

建议值为0.2  

### 无约束MPC更适合处理哪类控制问题？  

作为理解MPC的起点，无约束MPC有解析解（即$\Delta U^*(k)$)。在开发新的MPC算法（如分布式MPC、自适应MPC）时，常先在无约束线性问题上验证核心思想的正确性和收敛性。无约束MPC更适合线性度好、约束非关键、对计算速度要求极高的场景。一旦约束成为核心矛盾，就必须使用带约束的MPC。  

### 无约束MPC如何与状态观测器（如卡尔曼滤波器）结合？  

对于线性系统、二次目标函数、高斯白噪声的系统，分离原理严格成立时，只需要把原公式的状态实际值改为估计状态即可。其余公式（预测方程、目标函数、优化求解）在形式上完全不变。如果系统非线性较强或噪声非高斯，这种简单的替换虽然仍常用且往往有效，但其最优性和稳定性的理论保证将不再严格成立，此时需要更谨慎的设计和评估。  

## 相关代码

本节将针对算法给出关键矩阵的matlab代码。

$(3)-(5)$的代码：  

```matlab
n_c = size(Cc,1);%输出维数
n_x = size(A,1);%状态变量维数
n_u = size(Bu,2);%输入维数
n_d = size(Bd, 2);%可测扰动维数


% --- 生成 Sx 矩阵 ---
% 预分配结果矩阵
Sx = zeros(p * n_c, n_x);
% 初始化
cum_sum = zeros(n_c, n_x);  % 累积和
Ak = A;            % 初始为 A^1

for k = 1:p
    % 计算当前块的索引范围
    row_start = (k-1) * n_c + 1;
    row_end = k * n_c;
    
    % 更新累积和：cum_sum = cum_sum + Cc * A^k
    cum_sum = cum_sum + Cc * Ak;
    
    % 将累积和赋给当前块
    Sx(row_start:row_end, :) = cum_sum;
     Ak = Ak * A;
end

% --- 生成 I 矩阵 ---
I_ny = eye(n_c);
I = repmat(I_ny, p, 1);

% --- 生成 Sd 矩阵 ---
%预分配结果矩阵
Sd = zeros(p * n_c, n_d);
% 初始化
cum_sum = zeros(n_c, n_d);  
Ak = eye(n_x);            
for k = 1:p
    % 计算当前块的索引范围
    row_start = (k-1) * n_c + 1;
    row_end = k * n_c;
    
    % 更新累积和：cum_sum = cum_sum + Cc * A^(k-1)*Bd
    cum_sum = cum_sum + Cc * Ak*Bd;
    
    % 将累积和赋给当前块
    Sd(row_start:row_end, :) = cum_sum;
     Ak = Ak * A;
end

% --- 生成 Su 矩阵 ---
%使用三维数组存储所有H(k) (n_y × n_u × p)
H_array = zeros(n_c, n_u, p);
% 计算阶跃响应矩阵序列
Ak = eye(n_x);  % A^0
H_array(:,:,1) = Cc * Ak * Bu;  % H(1) = Cc * Bu
for k = 2:p
    Ak = A * Ak;  % 更新到 A^(k-1)
    H_array(:,:,k) = H_array(:,:,k-1) + Cc * Ak * Bu;  % 累积和
end
Su = zeros(p*n_c, m*n_u);
for i = 1:p
    for j = 1:m
        idx = i - j + 1;
        if idx >= 1
            Su(i, j) = H_array(idx);
        else
            Su(i, j) = 0;
        end
    end
end
```

加权矩阵与归一化的代码：  

```matlab
% === 1. 定义物理量纲的缩放因子 ===
% 设定一个标称的最大值，用于将数据映射到 [0, 1] 区间附近
deg2rad_factor = pi/180;
y_max_scale = 20 * deg2rad_factor;  % 假设允许最大横摇为 20度 (转换为弧度)
u_max_scale = 5e6;                  % 假设最大控制力矩/增量约为 5*10^6 N·m (根据J和C_phi估算)

% === 2. 定义无量纲的权重系数 ===
% 现在这两个参数可以在 0.1 到 20 之间调整，意义更直观
% weight_y 越大，越看重减摇效果
% weight_u 越大，越看重节省能量/保护执行机构
%为了简单起见，采取恒值的加权因子
weight_y = 1;     %默认为1
weight_u = 1;     %默认为1

% === 3. 构建加权矩阵 (包含归一化) ===
% 误差加权因子
% 创建一个 n_c×n_c 的对角块模板
block_template = eye(n_c)*weight_y/y_max_scale; 
% 初始化总矩阵
Fy = zeros(n_c * p, n_c * p);
% 填充对角块
for i = 1:p
    % 计算当前块在总矩阵中的位置
    row_start = (i-1)*n_c + 1;
    row_end = i*n_c;
    col_start = (i-1)*n_c + 1;
    col_end = i*n_c;
    
    % 放置对角块
    Fy(row_start:row_end, col_start:col_end) = block_template;
end

% 控制增量加权因子 Fu 
% 创建一个 n_u×n_u 的对角块模板
block_template = eye(n_u)*weight_u/u_max_scale; 
% 初始化总矩阵
Fu = zeros(n_u * m, n_u * m);
% 填充对角块
for i = 1:m
    % 计算当前块在总矩阵中的位置
    row_start = (i-1)*n_u + 1;
    row_end = i*n_u;
    col_start = (i-1)*n_u + 1;
    col_end = i*n_u;
    
    % 放置对角块
    Fu(row_start:row_end, col_start:col_end) = block_template;
end

% === 4. 计算 K_mpc ===
H = (Su' * (Fy') * Fy * Su) + (Fu' * Fu);
G = Su' * (Fy' * Fy);
% 建议使用左除 '\' 代替 inv() 以提高数值稳定性
K_mpc_total = H \ G; 
% 只取第一个控制增量
K_mpc = K_mpc_total(1:n_u, :);
```

完整代码请参见：https://github.com/Alyxx17/MPC-Control-Tutorial

## 参考 
模型预测控制/陈虹著.——北京:科学出版社,2013(系统与控制丛书),ISBN 978-7–03–038143-9  

Matlab关于采样周期，预测时域，控制时域选取的建议：https://ww2.mathworks.cn/help/mpc/ug/choosing-sample-time-and-horizons.html  

Matlab关于加权矩阵选取的建议:https://ww2.mathworks.cn/help/mpc/ug/tuning-weights.html

Matlab关于归一化的方法：https://ww2.mathworks.cn/help/mpc/ug/scale-factors.html

网上相关资源  




